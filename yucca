#!/usr/bin/env python

# Copyright (c)2012 Chris Pressey, Cat's Eye Technologies
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

import re
import sys
import fileinput
from optparse import OptionParser


class BasicCommand(object):
    @classmethod
    def create(class_, text):
        match = re.match(r'^\s*rem(.*)$', text, re.I)
        if match:
            return Remark(match.group(1))
        match = re.match(r'^\s*goto\s*(\d+)\s*$', text, re.I)
        if match:
            return Goto(int(match.group(1)))
        match = re.match(r'^\s*gosub\s*(\d+)\s*$', text, re.I)
        if match:
            return Gosub(int(match.group(1)))
        match = re.match(r'^\s*(if(.*?)(then|goto))\s*(\d+)\s*$', text, re.I)
        if match:
            return IfThenLine(match.group(1), int(match.group(4)))
        match = re.match(r'^\s*(if(.*?)then)\s*(.*?)\s*$', text, re.I)
        if match:
            return IfThen(match.group(1), BasicCommand.create(match.group(3)))
        match = re.match(r'^\s*(on(.*?)go(to|sub))\s*(.*?)\s*$', text, re.I)
        if match:
            line_numbers = [int(x.strip()) for x in match.group(4).split(',')]
            return OnLines(match.group(1), line_numbers)
        return GenericCommand(text)

    def referenced_line_numbers(self):
        raise NotImplementedError


class GenericCommand(BasicCommand):
    def __init__(self, text):
        self.text = text

    def __str__(self):
        return self.text

    def referenced_line_numbers(self):
        return []


class Remark(BasicCommand):
    def __init__(self, text):
        self.text = text

    def __str__(self):
        return "REM%s" % (self.text)

    def referenced_line_numbers(self):
        return []


class IfThen(BasicCommand):
    def __init__(self, body, subsequent):
        self.body = body
        self.subsequent = subsequent

    def __str__(self):
        return "%s %s" % (self.body, self.subsequent)

    def referenced_line_numbers(self):
        return self.subsequent.referenced_line_numbers()


class IfThenLine(BasicCommand):
    def __init__(self, body, line_number):
        self.body = body
        self.line_number = line_number

    def __str__(self):
        return "%s %s" % (self.body, self.line_number)

    def referenced_line_numbers(self):
        return [self.line_number]


class Goto(BasicCommand):
    def __init__(self, line_number):
        self.line_number = line_number

    def __str__(self):
        return "GOTO %s" % self.line_number

    def referenced_line_numbers(self):
        return [self.line_number]


class Gosub(BasicCommand):
    def __init__(self, line_number):
        self.line_number = line_number

    def __str__(self):
        return "GOSUB %s" % self.line_number

    def referenced_line_numbers(self):
        return [self.line_number]


class OnLines(BasicCommand):
    def __init__(self, body, line_numbers):
        self.body = body
        self.line_numbers = line_numbers

    def __str__(self):
        return "%s %s" % (self.body,
                          ','.join(str(x) for x in self.line_numbers))

    def referenced_line_numbers(self):
        return self.line_numbers


class BasicLine(object):
    def __init__(self, text):
        self.line_number = None
        text = text.strip()
        match = re.match(r'^(\d+)\s+(.*?)$', text)
        if match:
            self.line_number = int(match.group(1))
            text = match.group(2)

        self.commands = []

        index = 0
        start = 0
        state = 'start'
        while index < len(text):
            if state in ('start', 'cmd'):
                match = re.match(r'^rem', text[index:], re.I)
                if match:
                    state = 'remark'
                else:
                    state = 'cmd'
            if state == 'cmd':
                if text[index] == '"':
                    state = 'quoted'
                elif text[index] == ':':
                    cmd = BasicCommand.create(text[start:index])
                    self.commands.append(cmd)
                    start = index + 1
                    state = 'start'
            elif state == 'quoted':
                if text[index] == '"':
                    state = 'cmd'
            elif state == 'remark':
                pass
            index += 1
        cmd = BasicCommand.create(text[start:index])
        self.commands.append(cmd)

    def __str__(self):
        text = ':'.join(str(x) for x in self.commands)
        if self.line_number:
            return "%s %s" % (self.line_number, text)
        else:
            return text

    def referenced_line_numbers(self):
        line_numbers = []
        for command in self.commands:
            line_numbers.extend(command.referenced_line_numbers())
        return line_numbers

    def strip_remarks(self):
        new_commands = []
        for command in self.commands:
            if not isinstance(command, Remark):
                new_commands.append(command)
        new_line = BasicLine('')
        if new_commands:
            new_line.line_number = self.line_number
            new_line.commands = new_commands
            return new_line
        else:
            return None


class BasicProgram(object):
    r"""An object which represents a BASIC program.

    >>> b = BasicProgram('10 PRINT "HELLO"\n'
    ...                  '20 GOTO 10\n')
    >>> b.dump()
    10 PRINT "HELLO"
    20 GOTO 10
    >>> len(b.lines)
    2
    >>> print b.lines[0].commands[0]
    PRINT "HELLO"
    >>> print b.lines[1].commands[0].__class__.__name__
    Goto

    >>> b = BasicProgram()
    >>> b.add_line('10 PRINT "HELLO"')
    >>> b.add_line('20 GOTO 30')
    >>> len(b.lines)
    2
    >>> num_errors = b.check_line_numbers()
    ?UNDEFINED STATEMENT "30" IN: 20 GOTO 30
    >>> num_errors
    1

    >>> b = BasicProgram('5 goSUb 10\n'
    ...                  '7 goSUb 8\n'
    ...                  '10 oN (X+1 )* 5  gOtO 100, 6')
    >>> num_errors = b.check_line_numbers()
    ?UNDEFINED STATEMENT "100" IN: 10 oN (X+1 )* 5  gOtO 100,6
    ?UNDEFINED STATEMENT "6" IN: 10 oN (X+1 )* 5  gOtO 100,6
    ?UNDEFINED STATEMENT "8" IN: 7 GOSUB 8

    >>> b = BasicProgram('10 REM HELLO: GOTO 20')
    >>> len(b.lines[0].commands)
    1
    >>> print b.lines[0].commands[0].__class__.__name__
    Remark
    >>> b.check_line_numbers()
    0

    >>> b = BasicProgram('10 REM HELLO\n'
    ...                  'PRINT "HELLO"\n'
    ...                  'GOTO 20')
    >>> num_errors = b.check_line_numbers()
    ?UNDEFINED STATEMENT "20" IN: GOTO 20 (immediate mode, text file line 3)
    >>> b.strip_immediate_mode_commands()
    >>> b.dump()
    10 REM HELLO
    >>> b.check_line_numbers()
    0

    >>> b = BasicProgram('10 PRINT "HI":REM HELLO\n'
    ...                  'PRINT "HELLO"\n'
    ...                  'REM WHAT?\n'
    ...                  '20 GOTO 30\n'
    ...                  '30 REM THIS IS BUNK, MAN\n')
    >>> b.strip_remarks()
    >>> b.dump()
    10 PRINT "HI"
    PRINT "HELLO"
    20 GOTO 30
    >>> num_errors = b.check_line_numbers()
    ?UNDEFINED STATEMENT "30" IN: 20 GOTO 30

    """
    def __init__(self, text=None):
        self.lines = []
        if text is not None:
            for line in text.rstrip('\r\n').split('\n'):
                self.add_line(line)

    def add_line(self, line):
        self.lines.append(BasicLine(line))

    def check_line_numbers(self):
        referenced = {}
        defined = {}
        errors = 0
        text_file_line = 1
        for line in self.lines:
            if line.line_number is not None:
                location = line.line_number
                defined[location] = line
            else:
                location = "IMMEDIATE MODE (line %d)" % text_file_line
                defined[location] = "%s (immediate mode, text file line %d)" % \
                  (line, text_file_line)
            referenced[location] = line.referenced_line_numbers()
            text_file_line += 1
        for (line_number, referenced_line_numbers) in referenced.iteritems():
            for referenced_line_number in referenced_line_numbers:
                if referenced_line_number not in defined:
                    print '?UNDEFINED STATEMENT "%s" IN: %s' % (
                        referenced_line_number, defined[line_number])
                    errors += 1
        return errors

    def strip_immediate_mode_commands(self):
        new_lines = []
        for line in self.lines:
            if line.line_number is not None:
                new_lines.append(line)
        self.lines = new_lines

    def strip_remarks(self):
        new_lines = []
        for line in self.lines:
            new_line = line.strip_remarks()
            if new_line is not None:
                new_lines.append(new_line)
        self.lines = new_lines

    def dump(self):
        for line in self.lines:
            print line


if __name__ == '__main__':
    parser = OptionParser()
    parser.add_option("-I", "--strip-immediate-mode",
                      dest="strip_immediate_mode",
                      action="store_true",
                      help="strip immediate mode commands (implies -o)")
    parser.add_option("-L", "--no-check-line-numbers",
                      dest="check_line_numbers",
                      default=True,
                      action="store_false",
                      help="do not check that all target line numbers exist")
    parser.add_option("-o", "--dump-output",
                      dest="dump_output",
                      action="store_true",
                      help="dump (possibly transformed) program to standard "
                           "output; implied by other options")
    parser.add_option("-R", "--strip-remarks",
                      dest="strip_remarks",
                      action="store_true",
                      help="strip all REM statements from program (implies -o)")
    parser.add_option("-t", "--test",
                      action="store_true", dest="test", default=False,
                      help="run internal test cases and exit")

    (options, args) = parser.parse_args()

    if options.test:
        import doctest
        doctest.testmod()
        sys.exit(0)

    p = BasicProgram()
    for line in fileinput.input(args):
        p.add_line(line)

    if options.strip_immediate_mode:
        options.dump_output = True
        p.strip_immediate_mode_commands()

    if options.strip_remarks:
        options.dump_output = True
        p.strip_remarks()

    errors = 0
    if options.check_line_numbers:
        errors += p.check_line_numbers()

    if errors > 0:
        sys.exit(1)

    if options.dump_output:
        p.dump()

    sys.exit(0)
